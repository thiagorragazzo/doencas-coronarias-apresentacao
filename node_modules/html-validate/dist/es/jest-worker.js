import { workerData, parentPort } from 'node:worker_threads';
import { F as FileSystemConfigLoader } from './core-nodejs.js';
import { H as HtmlValidate } from './core.js';
import 'node:fs';
import 'node:path';
import 'node:module';
import 'kleur';
import 'ajv';
import './elements.js';
import './meta-helper.js';
import './utils/natural-join.js';
import '@sidvind/better-ajv-errors';
import '@html-validate/stylish';
import 'semver';

function runAsWorker(fn) {
  if (!workerData) {
    return;
  }
  const { workerPort, sharedBuffer } = workerData;
  const sharedBufferView = new Int32Array(sharedBuffer, 0, 1);
  parentPort.on("message", ({ id, args }) => {
    async function inner() {
      let isAborted = false;
      const handleAbortMessage = (msg2) => {
        if (msg2.id === id && msg2.cmd === "abort") {
          isAborted = true;
        }
      };
      workerPort.on("message", handleAbortMessage);
      let msg;
      try {
        msg = { id, result: await fn(...args) };
      } catch (error) {
        msg = {
          id,
          error: error instanceof Error ? error.message : String(error)
        };
      }
      workerPort.off("message", handleAbortMessage);
      if (isAborted) {
        return;
      }
      workerPort.postMessage(msg);
      Atomics.add(sharedBufferView, 0, 1);
      Atomics.notify(sharedBufferView, 0);
    }
    inner();
  });
}
function validateString(markup, filename, config) {
  const loader = new FileSystemConfigLoader({
    extends: ["html-validate:recommended"]
  });
  const htmlvalidate = new HtmlValidate(loader);
  return htmlvalidate.validateString(markup, filename, config);
}
runAsWorker(validateString);
//# sourceMappingURL=jest-worker.js.map
